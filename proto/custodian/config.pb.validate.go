// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/custodian/config.proto

package config

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ConfigMultiError, or nil if none found.
func (m *Config) ValidateAll() error {
	return m.validate(true)
}

func (m *Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNetworking()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Networking",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Networking",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNetworking()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "Networking",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCompute()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Compute",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompute()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "Compute",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLoadBalancers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("LoadBalancers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigValidationError{
						field:  fmt.Sprintf("LoadBalancers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigValidationError{
					field:  fmt.Sprintf("LoadBalancers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIam()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Iam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Iam",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIam()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "Iam",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "Storage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "Storage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigMultiError(errors)
	}

	return nil
}

// ConfigMultiError is an error wrapping multiple validation errors returned by
// Config.ValidateAll() if the designated constraints aren't met.
type ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMultiError) AllErrors() []error { return m }

// ConfigValidationError is the validation error returned by Config.Validate if
// the designated constraints aren't met.
type ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigValidationError) ErrorName() string { return "ConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigValidationError{}

// Validate checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProjectMultiError, or nil if none found.
func (m *Project) ValidateAll() error {
	return m.validate(true)
}

func (m *Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for BillingAccount

	// no validation rules for OrganizationId

	// no validation rules for FolderId

	// no validation rules for Labels

	if len(errors) > 0 {
		return ProjectMultiError(errors)
	}

	return nil
}

// ProjectMultiError is an error wrapping multiple validation errors returned
// by Project.ValidateAll() if the designated constraints aren't met.
type ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectMultiError) AllErrors() []error { return m }

// ProjectValidationError is the validation error returned by Project.Validate
// if the designated constraints aren't met.
type ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectValidationError) ErrorName() string { return "ProjectValidationError" }

// Error satisfies the builtin error interface
func (e ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectValidationError{}

// Validate checks the field values on Networking with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Networking) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Networking with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NetworkingMultiError, or
// nil if none found.
func (m *Networking) ValidateAll() error {
	return m.validate(true)
}

func (m *Networking) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReservedIps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("ReservedIps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("ReservedIps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  fmt.Sprintf("ReservedIps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetVpcs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("Vpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("Vpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  fmt.Sprintf("Vpcs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFirewallRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("FirewallRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("FirewallRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  fmt.Sprintf("FirewallRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetNatGateways() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("NatGateways[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkingValidationError{
						field:  fmt.Sprintf("NatGateways[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkingValidationError{
					field:  fmt.Sprintf("NatGateways[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NetworkingMultiError(errors)
	}

	return nil
}

// NetworkingMultiError is an error wrapping multiple validation errors
// returned by Networking.ValidateAll() if the designated constraints aren't met.
type NetworkingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkingMultiError) AllErrors() []error { return m }

// NetworkingValidationError is the validation error returned by
// Networking.Validate if the designated constraints aren't met.
type NetworkingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkingValidationError) ErrorName() string { return "NetworkingValidationError" }

// Error satisfies the builtin error interface
func (e NetworkingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworking.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkingValidationError{}

// Validate checks the field values on ReservedIp with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReservedIp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReservedIp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReservedIpMultiError, or
// nil if none found.
func (m *ReservedIp) ValidateAll() error {
	return m.validate(true)
}

func (m *ReservedIp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Region

	// no validation rules for NetworkTier

	// no validation rules for Description

	if len(errors) > 0 {
		return ReservedIpMultiError(errors)
	}

	return nil
}

// ReservedIpMultiError is an error wrapping multiple validation errors
// returned by ReservedIp.ValidateAll() if the designated constraints aren't met.
type ReservedIpMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReservedIpMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReservedIpMultiError) AllErrors() []error { return m }

// ReservedIpValidationError is the validation error returned by
// ReservedIp.Validate if the designated constraints aren't met.
type ReservedIpValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReservedIpValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReservedIpValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReservedIpValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReservedIpValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReservedIpValidationError) ErrorName() string { return "ReservedIpValidationError" }

// Error satisfies the builtin error interface
func (e ReservedIpValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReservedIp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReservedIpValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReservedIpValidationError{}

// Validate checks the field values on Vpc with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Vpc) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Vpc with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in VpcMultiError, or nil if none found.
func (m *Vpc) ValidateAll() error {
	return m.validate(true)
}

func (m *Vpc) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	for idx, item := range m.GetSubnets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VpcValidationError{
						field:  fmt.Sprintf("Subnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VpcValidationError{
						field:  fmt.Sprintf("Subnets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VpcValidationError{
					field:  fmt.Sprintf("Subnets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AutoCreateSubnetworks

	// no validation rules for RoutingMode

	if len(errors) > 0 {
		return VpcMultiError(errors)
	}

	return nil
}

// VpcMultiError is an error wrapping multiple validation errors returned by
// Vpc.ValidateAll() if the designated constraints aren't met.
type VpcMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VpcMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VpcMultiError) AllErrors() []error { return m }

// VpcValidationError is the validation error returned by Vpc.Validate if the
// designated constraints aren't met.
type VpcValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VpcValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VpcValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VpcValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VpcValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VpcValidationError) ErrorName() string { return "VpcValidationError" }

// Error satisfies the builtin error interface
func (e VpcValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVpc.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VpcValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VpcValidationError{}

// Validate checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subnet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subnet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SubnetMultiError, or nil if none found.
func (m *Subnet) ValidateAll() error {
	return m.validate(true)
}

func (m *Subnet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Cidr

	// no validation rules for Region

	// no validation rules for Description

	// no validation rules for PrivateIpGoogleAccess

	for idx, item := range m.GetSecondaryRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubnetValidationError{
						field:  fmt.Sprintf("SecondaryRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubnetValidationError{
						field:  fmt.Sprintf("SecondaryRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubnetValidationError{
					field:  fmt.Sprintf("SecondaryRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubnetMultiError(errors)
	}

	return nil
}

// SubnetMultiError is an error wrapping multiple validation errors returned by
// Subnet.ValidateAll() if the designated constraints aren't met.
type SubnetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubnetMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubnetMultiError) AllErrors() []error { return m }

// SubnetValidationError is the validation error returned by Subnet.Validate if
// the designated constraints aren't met.
type SubnetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubnetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubnetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubnetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubnetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubnetValidationError) ErrorName() string { return "SubnetValidationError" }

// Error satisfies the builtin error interface
func (e SubnetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubnet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubnetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubnetValidationError{}

// Validate checks the field values on SecondaryRange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecondaryRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecondaryRange with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecondaryRangeMultiError,
// or nil if none found.
func (m *SecondaryRange) ValidateAll() error {
	return m.validate(true)
}

func (m *SecondaryRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RangeName

	// no validation rules for IpCidrRange

	if len(errors) > 0 {
		return SecondaryRangeMultiError(errors)
	}

	return nil
}

// SecondaryRangeMultiError is an error wrapping multiple validation errors
// returned by SecondaryRange.ValidateAll() if the designated constraints
// aren't met.
type SecondaryRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecondaryRangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecondaryRangeMultiError) AllErrors() []error { return m }

// SecondaryRangeValidationError is the validation error returned by
// SecondaryRange.Validate if the designated constraints aren't met.
type SecondaryRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecondaryRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecondaryRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecondaryRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecondaryRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecondaryRangeValidationError) ErrorName() string { return "SecondaryRangeValidationError" }

// Error satisfies the builtin error interface
func (e SecondaryRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecondaryRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecondaryRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecondaryRangeValidationError{}

// Validate checks the field values on FirewallRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirewallRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirewallRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirewallRuleMultiError, or
// nil if none found.
func (m *FirewallRule) ValidateAll() error {
	return m.validate(true)
}

func (m *FirewallRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Direction

	// no validation rules for Priority

	// no validation rules for Network

	for idx, item := range m.GetAllow() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FirewallRuleValidationError{
						field:  fmt.Sprintf("Allow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FirewallRuleValidationError{
						field:  fmt.Sprintf("Allow[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FirewallRuleValidationError{
					field:  fmt.Sprintf("Allow[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeny() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FirewallRuleValidationError{
						field:  fmt.Sprintf("Deny[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FirewallRuleValidationError{
						field:  fmt.Sprintf("Deny[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FirewallRuleValidationError{
					field:  fmt.Sprintf("Deny[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FirewallRuleMultiError(errors)
	}

	return nil
}

// FirewallRuleMultiError is an error wrapping multiple validation errors
// returned by FirewallRule.ValidateAll() if the designated constraints aren't met.
type FirewallRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirewallRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirewallRuleMultiError) AllErrors() []error { return m }

// FirewallRuleValidationError is the validation error returned by
// FirewallRule.Validate if the designated constraints aren't met.
type FirewallRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirewallRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirewallRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirewallRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirewallRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirewallRuleValidationError) ErrorName() string { return "FirewallRuleValidationError" }

// Error satisfies the builtin error interface
func (e FirewallRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirewallRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirewallRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirewallRuleValidationError{}

// Validate checks the field values on FirewallAllow with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirewallAllow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirewallAllow with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirewallAllowMultiError, or
// nil if none found.
func (m *FirewallAllow) ValidateAll() error {
	return m.validate(true)
}

func (m *FirewallAllow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Protocol

	if len(errors) > 0 {
		return FirewallAllowMultiError(errors)
	}

	return nil
}

// FirewallAllowMultiError is an error wrapping multiple validation errors
// returned by FirewallAllow.ValidateAll() if the designated constraints
// aren't met.
type FirewallAllowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirewallAllowMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirewallAllowMultiError) AllErrors() []error { return m }

// FirewallAllowValidationError is the validation error returned by
// FirewallAllow.Validate if the designated constraints aren't met.
type FirewallAllowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirewallAllowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirewallAllowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirewallAllowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirewallAllowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirewallAllowValidationError) ErrorName() string { return "FirewallAllowValidationError" }

// Error satisfies the builtin error interface
func (e FirewallAllowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirewallAllow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirewallAllowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirewallAllowValidationError{}

// Validate checks the field values on FirewallDeny with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirewallDeny) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirewallDeny with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirewallDenyMultiError, or
// nil if none found.
func (m *FirewallDeny) ValidateAll() error {
	return m.validate(true)
}

func (m *FirewallDeny) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Protocol

	if len(errors) > 0 {
		return FirewallDenyMultiError(errors)
	}

	return nil
}

// FirewallDenyMultiError is an error wrapping multiple validation errors
// returned by FirewallDeny.ValidateAll() if the designated constraints aren't met.
type FirewallDenyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirewallDenyMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirewallDenyMultiError) AllErrors() []error { return m }

// FirewallDenyValidationError is the validation error returned by
// FirewallDeny.Validate if the designated constraints aren't met.
type FirewallDenyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirewallDenyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirewallDenyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirewallDenyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirewallDenyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirewallDenyValidationError) ErrorName() string { return "FirewallDenyValidationError" }

// Error satisfies the builtin error interface
func (e FirewallDenyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirewallDeny.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirewallDenyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirewallDenyValidationError{}

// Validate checks the field values on NatGateway with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NatGateway) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NatGateway with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NatGatewayMultiError, or
// nil if none found.
func (m *NatGateway) ValidateAll() error {
	return m.validate(true)
}

func (m *NatGateway) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Region

	// no validation rules for Router

	// no validation rules for NatIpAllocateOption

	for idx, item := range m.GetSourceSubnetworkIpRangesToNat() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NatGatewayValidationError{
						field:  fmt.Sprintf("SourceSubnetworkIpRangesToNat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NatGatewayValidationError{
						field:  fmt.Sprintf("SourceSubnetworkIpRangesToNat[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NatGatewayValidationError{
					field:  fmt.Sprintf("SourceSubnetworkIpRangesToNat[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NatGatewayMultiError(errors)
	}

	return nil
}

// NatGatewayMultiError is an error wrapping multiple validation errors
// returned by NatGateway.ValidateAll() if the designated constraints aren't met.
type NatGatewayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NatGatewayMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NatGatewayMultiError) AllErrors() []error { return m }

// NatGatewayValidationError is the validation error returned by
// NatGateway.Validate if the designated constraints aren't met.
type NatGatewayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NatGatewayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NatGatewayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NatGatewayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NatGatewayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NatGatewayValidationError) ErrorName() string { return "NatGatewayValidationError" }

// Error satisfies the builtin error interface
func (e NatGatewayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNatGateway.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NatGatewayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NatGatewayValidationError{}

// Validate checks the field values on NatSubnetwork with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NatSubnetwork) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NatSubnetwork with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NatSubnetworkMultiError, or
// nil if none found.
func (m *NatSubnetwork) ValidateAll() error {
	return m.validate(true)
}

func (m *NatSubnetwork) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return NatSubnetworkMultiError(errors)
	}

	return nil
}

// NatSubnetworkMultiError is an error wrapping multiple validation errors
// returned by NatSubnetwork.ValidateAll() if the designated constraints
// aren't met.
type NatSubnetworkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NatSubnetworkMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NatSubnetworkMultiError) AllErrors() []error { return m }

// NatSubnetworkValidationError is the validation error returned by
// NatSubnetwork.Validate if the designated constraints aren't met.
type NatSubnetworkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NatSubnetworkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NatSubnetworkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NatSubnetworkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NatSubnetworkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NatSubnetworkValidationError) ErrorName() string { return "NatSubnetworkValidationError" }

// Error satisfies the builtin error interface
func (e NatSubnetworkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNatSubnetwork.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NatSubnetworkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NatSubnetworkValidationError{}

// Validate checks the field values on Compute with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Compute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Compute with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ComputeMultiError, or nil if none found.
func (m *Compute) ValidateAll() error {
	return m.validate(true)
}

func (m *Compute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstanceTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("InstanceTemplates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("InstanceTemplates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  fmt.Sprintf("InstanceTemplates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstanceGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("InstanceGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("InstanceGroups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  fmt.Sprintf("InstanceGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputeValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputeValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ComputeMultiError(errors)
	}

	return nil
}

// ComputeMultiError is an error wrapping multiple validation errors returned
// by Compute.ValidateAll() if the designated constraints aren't met.
type ComputeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputeMultiError) AllErrors() []error { return m }

// ComputeValidationError is the validation error returned by Compute.Validate
// if the designated constraints aren't met.
type ComputeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputeValidationError) ErrorName() string { return "ComputeValidationError" }

// Error satisfies the builtin error interface
func (e ComputeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputeValidationError{}

// Validate checks the field values on InstanceTemplate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstanceTemplate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceTemplate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceTemplateMultiError, or nil if none found.
func (m *InstanceTemplate) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceTemplate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for MachineType

	// no validation rules for Image

	// no validation rules for DiskSizeGb

	// no validation rules for DiskType

	for idx, item := range m.GetNetworkInterfaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceTemplateValidationError{
						field:  fmt.Sprintf("NetworkInterfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceTemplateValidationError{
						field:  fmt.Sprintf("NetworkInterfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceTemplateValidationError{
					field:  fmt.Sprintf("NetworkInterfaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ServiceAccount

	// no validation rules for Metadata

	// no validation rules for Labels

	// no validation rules for StartupScript

	// no validation rules for Preemptible

	if len(errors) > 0 {
		return InstanceTemplateMultiError(errors)
	}

	return nil
}

// InstanceTemplateMultiError is an error wrapping multiple validation errors
// returned by InstanceTemplate.ValidateAll() if the designated constraints
// aren't met.
type InstanceTemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceTemplateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceTemplateMultiError) AllErrors() []error { return m }

// InstanceTemplateValidationError is the validation error returned by
// InstanceTemplate.Validate if the designated constraints aren't met.
type InstanceTemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceTemplateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceTemplateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceTemplateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceTemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceTemplateValidationError) ErrorName() string { return "InstanceTemplateValidationError" }

// Error satisfies the builtin error interface
func (e InstanceTemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceTemplate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceTemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceTemplateValidationError{}

// Validate checks the field values on NetworkInterface with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NetworkInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkInterface with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NetworkInterfaceMultiError, or nil if none found.
func (m *NetworkInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Network

	// no validation rules for Subnetwork

	for idx, item := range m.GetAccessConfigs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NetworkInterfaceValidationError{
						field:  fmt.Sprintf("AccessConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NetworkInterfaceValidationError{
						field:  fmt.Sprintf("AccessConfigs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NetworkInterfaceValidationError{
					field:  fmt.Sprintf("AccessConfigs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NetworkInterfaceMultiError(errors)
	}

	return nil
}

// NetworkInterfaceMultiError is an error wrapping multiple validation errors
// returned by NetworkInterface.ValidateAll() if the designated constraints
// aren't met.
type NetworkInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkInterfaceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkInterfaceMultiError) AllErrors() []error { return m }

// NetworkInterfaceValidationError is the validation error returned by
// NetworkInterface.Validate if the designated constraints aren't met.
type NetworkInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkInterfaceValidationError) ErrorName() string { return "NetworkInterfaceValidationError" }

// Error satisfies the builtin error interface
func (e NetworkInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkInterfaceValidationError{}

// Validate checks the field values on AccessConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccessConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccessConfigMultiError, or
// nil if none found.
func (m *AccessConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for NatIp

	// no validation rules for NetworkTier

	if len(errors) > 0 {
		return AccessConfigMultiError(errors)
	}

	return nil
}

// AccessConfigMultiError is an error wrapping multiple validation errors
// returned by AccessConfig.ValidateAll() if the designated constraints aren't met.
type AccessConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessConfigMultiError) AllErrors() []error { return m }

// AccessConfigValidationError is the validation error returned by
// AccessConfig.Validate if the designated constraints aren't met.
type AccessConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessConfigValidationError) ErrorName() string { return "AccessConfigValidationError" }

// Error satisfies the builtin error interface
func (e AccessConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessConfigValidationError{}

// Validate checks the field values on InstanceGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceGroup with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceGroupMultiError, or
// nil if none found.
func (m *InstanceGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Template

	// no validation rules for Size

	if all {
		switch v := interface{}(m.GetAutoScaling()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceGroupValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceGroupValidationError{
					field:  "AutoScaling",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAutoScaling()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceGroupValidationError{
				field:  "AutoScaling",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetNamedPorts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceGroupValidationError{
						field:  fmt.Sprintf("NamedPorts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceGroupValidationError{
						field:  fmt.Sprintf("NamedPorts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceGroupValidationError{
					field:  fmt.Sprintf("NamedPorts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for BaseInstanceName

	if len(errors) > 0 {
		return InstanceGroupMultiError(errors)
	}

	return nil
}

// InstanceGroupMultiError is an error wrapping multiple validation errors
// returned by InstanceGroup.ValidateAll() if the designated constraints
// aren't met.
type InstanceGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceGroupMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceGroupMultiError) AllErrors() []error { return m }

// InstanceGroupValidationError is the validation error returned by
// InstanceGroup.Validate if the designated constraints aren't met.
type InstanceGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceGroupValidationError) ErrorName() string { return "InstanceGroupValidationError" }

// Error satisfies the builtin error interface
func (e InstanceGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceGroupValidationError{}

// Validate checks the field values on AutoScaling with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AutoScaling) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoScaling with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AutoScalingMultiError, or
// nil if none found.
func (m *AutoScaling) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoScaling) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	// no validation rules for CpuTarget

	// no validation rules for CooldownPeriod

	if len(errors) > 0 {
		return AutoScalingMultiError(errors)
	}

	return nil
}

// AutoScalingMultiError is an error wrapping multiple validation errors
// returned by AutoScaling.ValidateAll() if the designated constraints aren't met.
type AutoScalingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoScalingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoScalingMultiError) AllErrors() []error { return m }

// AutoScalingValidationError is the validation error returned by
// AutoScaling.Validate if the designated constraints aren't met.
type AutoScalingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoScalingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoScalingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoScalingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoScalingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoScalingValidationError) ErrorName() string { return "AutoScalingValidationError" }

// Error satisfies the builtin error interface
func (e AutoScalingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoScaling.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoScalingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoScalingValidationError{}

// Validate checks the field values on NamedPort with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedPort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedPort with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedPortMultiError, or nil
// if none found.
func (m *NamedPort) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedPort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Port

	if len(errors) > 0 {
		return NamedPortMultiError(errors)
	}

	return nil
}

// NamedPortMultiError is an error wrapping multiple validation errors returned
// by NamedPort.ValidateAll() if the designated constraints aren't met.
type NamedPortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedPortMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedPortMultiError) AllErrors() []error { return m }

// NamedPortValidationError is the validation error returned by
// NamedPort.Validate if the designated constraints aren't met.
type NamedPortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedPortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedPortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedPortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedPortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedPortValidationError) ErrorName() string { return "NamedPortValidationError" }

// Error satisfies the builtin error interface
func (e NamedPortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedPort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedPortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedPortValidationError{}

// Validate checks the field values on Instance with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instance with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceMultiError, or nil
// if none found.
func (m *Instance) ValidateAll() error {
	return m.validate(true)
}

func (m *Instance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Zone

	// no validation rules for MachineType

	// no validation rules for Image

	for idx, item := range m.GetNetworkInterfaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceValidationError{
						field:  fmt.Sprintf("NetworkInterfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceValidationError{
						field:  fmt.Sprintf("NetworkInterfaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceValidationError{
					field:  fmt.Sprintf("NetworkInterfaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ServiceAccount

	// no validation rules for Metadata

	if len(errors) > 0 {
		return InstanceMultiError(errors)
	}

	return nil
}

// InstanceMultiError is an error wrapping multiple validation errors returned
// by Instance.ValidateAll() if the designated constraints aren't met.
type InstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceMultiError) AllErrors() []error { return m }

// InstanceValidationError is the validation error returned by
// Instance.Validate if the designated constraints aren't met.
type InstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceValidationError) ErrorName() string { return "InstanceValidationError" }

// Error satisfies the builtin error interface
func (e InstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceValidationError{}

// Validate checks the field values on LoadBalancer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoadBalancer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoadBalancer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoadBalancerMultiError, or
// nil if none found.
func (m *LoadBalancer) ValidateAll() error {
	return m.validate(true)
}

func (m *LoadBalancer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Ip

	// no validation rules for Backend

	// no validation rules for PortRange

	if all {
		switch v := interface{}(m.GetHealthCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoadBalancerValidationError{
					field:  "HealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoadBalancerValidationError{
					field:  "HealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoadBalancerValidationError{
				field:  "HealthCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoadBalancerMultiError(errors)
	}

	return nil
}

// LoadBalancerMultiError is an error wrapping multiple validation errors
// returned by LoadBalancer.ValidateAll() if the designated constraints aren't met.
type LoadBalancerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoadBalancerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoadBalancerMultiError) AllErrors() []error { return m }

// LoadBalancerValidationError is the validation error returned by
// LoadBalancer.Validate if the designated constraints aren't met.
type LoadBalancerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadBalancerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadBalancerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancerValidationError) ErrorName() string { return "LoadBalancerValidationError" }

// Error satisfies the builtin error interface
func (e LoadBalancerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancerValidationError{}

// Validate checks the field values on HealthCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthCheckMultiError, or
// nil if none found.
func (m *HealthCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Port

	// no validation rules for RequestPath

	// no validation rules for CheckIntervalSec

	// no validation rules for TimeoutSec

	// no validation rules for HealthyThreshold

	// no validation rules for UnhealthyThreshold

	if len(errors) > 0 {
		return HealthCheckMultiError(errors)
	}

	return nil
}

// HealthCheckMultiError is an error wrapping multiple validation errors
// returned by HealthCheck.ValidateAll() if the designated constraints aren't met.
type HealthCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheckMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheckMultiError) AllErrors() []error { return m }

// HealthCheckValidationError is the validation error returned by
// HealthCheck.Validate if the designated constraints aren't met.
type HealthCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheckValidationError) ErrorName() string { return "HealthCheckValidationError" }

// Error satisfies the builtin error interface
func (e HealthCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheckValidationError{}

// Validate checks the field values on Iam with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Iam) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Iam with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IamMultiError, or nil if none found.
func (m *Iam) ValidateAll() error {
	return m.validate(true)
}

func (m *Iam) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRoleBindings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IamValidationError{
						field:  fmt.Sprintf("RoleBindings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IamValidationError{
						field:  fmt.Sprintf("RoleBindings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IamValidationError{
					field:  fmt.Sprintf("RoleBindings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetServiceAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IamValidationError{
						field:  fmt.Sprintf("ServiceAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IamValidationError{
						field:  fmt.Sprintf("ServiceAccounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IamValidationError{
					field:  fmt.Sprintf("ServiceAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCustomRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IamValidationError{
						field:  fmt.Sprintf("CustomRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IamValidationError{
						field:  fmt.Sprintf("CustomRoles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IamValidationError{
					field:  fmt.Sprintf("CustomRoles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IamMultiError(errors)
	}

	return nil
}

// IamMultiError is an error wrapping multiple validation errors returned by
// Iam.ValidateAll() if the designated constraints aren't met.
type IamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IamMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IamMultiError) AllErrors() []error { return m }

// IamValidationError is the validation error returned by Iam.Validate if the
// designated constraints aren't met.
type IamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IamValidationError) ErrorName() string { return "IamValidationError" }

// Error satisfies the builtin error interface
func (e IamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IamValidationError{}

// Validate checks the field values on RoleBinding with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RoleBinding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RoleBinding with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RoleBindingMultiError, or
// nil if none found.
func (m *RoleBinding) ValidateAll() error {
	return m.validate(true)
}

func (m *RoleBinding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RoleBindingValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RoleBindingValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RoleBindingValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RoleBindingMultiError(errors)
	}

	return nil
}

// RoleBindingMultiError is an error wrapping multiple validation errors
// returned by RoleBinding.ValidateAll() if the designated constraints aren't met.
type RoleBindingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RoleBindingMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RoleBindingMultiError) AllErrors() []error { return m }

// RoleBindingValidationError is the validation error returned by
// RoleBinding.Validate if the designated constraints aren't met.
type RoleBindingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RoleBindingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RoleBindingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RoleBindingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RoleBindingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RoleBindingValidationError) ErrorName() string { return "RoleBindingValidationError" }

// Error satisfies the builtin error interface
func (e RoleBindingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoleBinding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RoleBindingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RoleBindingValidationError{}

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for Expression

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on ServiceAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceAccountMultiError,
// or nil if none found.
func (m *ServiceAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for GenerateKey

	if len(errors) > 0 {
		return ServiceAccountMultiError(errors)
	}

	return nil
}

// ServiceAccountMultiError is an error wrapping multiple validation errors
// returned by ServiceAccount.ValidateAll() if the designated constraints
// aren't met.
type ServiceAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceAccountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceAccountMultiError) AllErrors() []error { return m }

// ServiceAccountValidationError is the validation error returned by
// ServiceAccount.Validate if the designated constraints aren't met.
type ServiceAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceAccountValidationError) ErrorName() string { return "ServiceAccountValidationError" }

// Error satisfies the builtin error interface
func (e ServiceAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceAccountValidationError{}

// Validate checks the field values on CustomRole with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CustomRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CustomRole with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CustomRoleMultiError, or
// nil if none found.
func (m *CustomRole) ValidateAll() error {
	return m.validate(true)
}

func (m *CustomRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RoleId

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for Stage

	if len(errors) > 0 {
		return CustomRoleMultiError(errors)
	}

	return nil
}

// CustomRoleMultiError is an error wrapping multiple validation errors
// returned by CustomRole.ValidateAll() if the designated constraints aren't met.
type CustomRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CustomRoleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CustomRoleMultiError) AllErrors() []error { return m }

// CustomRoleValidationError is the validation error returned by
// CustomRole.Validate if the designated constraints aren't met.
type CustomRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CustomRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CustomRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CustomRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CustomRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CustomRoleValidationError) ErrorName() string { return "CustomRoleValidationError" }

// Error satisfies the builtin error interface
func (e CustomRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCustomRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CustomRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CustomRoleValidationError{}

// Validate checks the field values on Storage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Storage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Storage with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StorageMultiError, or nil if none found.
func (m *Storage) ValidateAll() error {
	return m.validate(true)
}

func (m *Storage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuckets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageValidationError{
					field:  fmt.Sprintf("Buckets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StorageMultiError(errors)
	}

	return nil
}

// StorageMultiError is an error wrapping multiple validation errors returned
// by Storage.ValidateAll() if the designated constraints aren't met.
type StorageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageMultiError) AllErrors() []error { return m }

// StorageValidationError is the validation error returned by Storage.Validate
// if the designated constraints aren't met.
type StorageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageValidationError) ErrorName() string { return "StorageValidationError" }

// Error satisfies the builtin error interface
func (e StorageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageValidationError{}

// Validate checks the field values on StorageBucket with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageBucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageBucket with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageBucketMultiError, or
// nil if none found.
func (m *StorageBucket) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageBucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Location

	// no validation rules for StorageClass

	// no validation rules for UniformBucketLevelAccess

	// no validation rules for Versioning

	// no validation rules for Labels

	for idx, item := range m.GetLifecycleRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StorageBucketValidationError{
						field:  fmt.Sprintf("LifecycleRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StorageBucketValidationError{
						field:  fmt.Sprintf("LifecycleRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StorageBucketValidationError{
					field:  fmt.Sprintf("LifecycleRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StorageBucketMultiError(errors)
	}

	return nil
}

// StorageBucketMultiError is an error wrapping multiple validation errors
// returned by StorageBucket.ValidateAll() if the designated constraints
// aren't met.
type StorageBucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageBucketMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageBucketMultiError) AllErrors() []error { return m }

// StorageBucketValidationError is the validation error returned by
// StorageBucket.Validate if the designated constraints aren't met.
type StorageBucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageBucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageBucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageBucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageBucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageBucketValidationError) ErrorName() string { return "StorageBucketValidationError" }

// Error satisfies the builtin error interface
func (e StorageBucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageBucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageBucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageBucketValidationError{}

// Validate checks the field values on LifecycleRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LifecycleRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LifecycleRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LifecycleRuleMultiError, or
// nil if none found.
func (m *LifecycleRule) ValidateAll() error {
	return m.validate(true)
}

func (m *LifecycleRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LifecycleRuleValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LifecycleRuleValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LifecycleRuleValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LifecycleRuleValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LifecycleRuleValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LifecycleRuleValidationError{
				field:  "Condition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LifecycleRuleMultiError(errors)
	}

	return nil
}

// LifecycleRuleMultiError is an error wrapping multiple validation errors
// returned by LifecycleRule.ValidateAll() if the designated constraints
// aren't met.
type LifecycleRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LifecycleRuleMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LifecycleRuleMultiError) AllErrors() []error { return m }

// LifecycleRuleValidationError is the validation error returned by
// LifecycleRule.Validate if the designated constraints aren't met.
type LifecycleRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LifecycleRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LifecycleRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LifecycleRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LifecycleRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LifecycleRuleValidationError) ErrorName() string { return "LifecycleRuleValidationError" }

// Error satisfies the builtin error interface
func (e LifecycleRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLifecycleRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LifecycleRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LifecycleRuleValidationError{}

// Validate checks the field values on LifecycleAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LifecycleAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LifecycleAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LifecycleActionMultiError, or nil if none found.
func (m *LifecycleAction) ValidateAll() error {
	return m.validate(true)
}

func (m *LifecycleAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for StorageClass

	if len(errors) > 0 {
		return LifecycleActionMultiError(errors)
	}

	return nil
}

// LifecycleActionMultiError is an error wrapping multiple validation errors
// returned by LifecycleAction.ValidateAll() if the designated constraints
// aren't met.
type LifecycleActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LifecycleActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LifecycleActionMultiError) AllErrors() []error { return m }

// LifecycleActionValidationError is the validation error returned by
// LifecycleAction.Validate if the designated constraints aren't met.
type LifecycleActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LifecycleActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LifecycleActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LifecycleActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LifecycleActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LifecycleActionValidationError) ErrorName() string { return "LifecycleActionValidationError" }

// Error satisfies the builtin error interface
func (e LifecycleActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLifecycleAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LifecycleActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LifecycleActionValidationError{}

// Validate checks the field values on LifecycleCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LifecycleCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LifecycleCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LifecycleConditionMultiError, or nil if none found.
func (m *LifecycleCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *LifecycleCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Age

	// no validation rules for CreatedBefore

	if len(errors) > 0 {
		return LifecycleConditionMultiError(errors)
	}

	return nil
}

// LifecycleConditionMultiError is an error wrapping multiple validation errors
// returned by LifecycleCondition.ValidateAll() if the designated constraints
// aren't met.
type LifecycleConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LifecycleConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LifecycleConditionMultiError) AllErrors() []error { return m }

// LifecycleConditionValidationError is the validation error returned by
// LifecycleCondition.Validate if the designated constraints aren't met.
type LifecycleConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LifecycleConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LifecycleConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LifecycleConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LifecycleConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LifecycleConditionValidationError) ErrorName() string {
	return "LifecycleConditionValidationError"
}

// Error satisfies the builtin error interface
func (e LifecycleConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLifecycleCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LifecycleConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LifecycleConditionValidationError{}
